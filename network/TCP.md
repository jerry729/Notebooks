<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

# TCP

1. 面向连接
2. 重发控制
3. 顺序控制



## 序列号与确认应答（ACK）

有确认应答，数据成功到达



无确认应答，

可能数据丢失

可能返回的确认应答丢失

确认应答延迟超时到达



确认应答、重发控制、重复控制 通过序列号实现ACK

序列号，也指字节与字节间的分隔，按顺序给发送字节的每一个都标上编号，编号初始值由随机数生成，每一个字节+1。

序列号中TCP数据长度的计算：IP首部中的数据包长度 - IP首部长度 - TCP首部长度



## 重发超时的确定

往返时间Round Trip Time（RTT）和 RTT的波动值、方差或抖动

重发超时时间 即比这个和稍大一点的值



超时以0.5s为单位，偏差最小值也是0.5s，因此最小的重发时间至少是1s

最初数据包不知道往返时间，重发超时一般设置为6s

数据重发后仍收不到确认应答，则再次发送，等待确认应答的时间以2倍、4倍的指数函数增长

达到一定重发次数后，仍没有确认应答，判定网络对端主机异常，强制关闭连接，通知应用通信异常强行终止



## 连接管理

数据通信前的SYN包（synchronize），作为建立连接的请求等待确认应答

通信结束断开连接的处理，FIN包



使用TCP首部用于控制的字段管理TCP的连接。一个连接的建立与断开至少需要来回的7个包



建立连接 three-way handshake 全互锁   客户端SYN -> 服务端ACK -> 客户端ACK

断开连接  客户端FIN -> 服务端ACK -> 服务端FIN -> 客户端ACK



## 以段为单位发送数据

最大消息长度Maximum Segment Size，正好是IP中不会被分片处理的最大数据长度

TCP传送数据时，以MSS为大小进行分割发送



MSS是三次握手时计算得出，发出建立连接请求时，在TCP首部中写入MSS选项，告诉对方自己能够适应的MSS大小，在两者间选择较小值。







## 利用窗口控制提高速度

原本：每发一个段停下来等待一次确认应答



窗口

窗口大小 无需等待确认应答而可以继续发送数据段数的最大值

使用大量缓冲区，可对多个段同时进行确认应答，发送端主机在等到确认应答返回之前，必须在缓冲区中保留这部分数据。



## 窗口控制与重发控制

使用窗口控制后，某些数据已经到达而确认应答未能返回的情况是不需要重发的，已经通过最后一个确认应答确认了下一个应接受的序列号

某个报文段丢失的情况，接收主机接收到一个自己应该接收序号以外的数据时，会针对当前为止收到的数据返回确认应答，但收到的序列号并不连续时不会丢弃而是暂时保存至缓冲区



## 流量控制

TCP提供一种机制，可以让发送端根据接收端的实际接收能力控制发送的数据量

接收端主机向发送端主机通知自己可以接收数据的大小，发送端发送不超过这个限度的数据，大小限度即窗口大小

TCP首部有个字段专门通知窗口大小

应答发送下一段序列号的同时，通知窗口大小

并且发送端主机不时发送窗口探测，收到接收端的窗口更新通知后通信继续。防止窗口更新通知在传送途中丢失，和缓冲区满后无法再次开始传送



## 拥塞控制

慢启动 最初拥塞窗口设置为1个段，每收到一个确认应答，窗口值增加1个段

将拥塞窗口的大小与接收端主机通知的窗口大小做比较，然后按照它们当中较小的那个值，发送比其还要小的数据量

慢启动阀值，当拥塞窗口大小超过阀值，则在每一次收到确认应答时，以以下比例放大拥塞窗口
$$
\frac{1个数据段的字节数}{拥塞窗口（字节）}\times 1个数据段字节数
$$
TCP刚开始通信时并没有设置相应的慢启动阀值（与窗口的最大值相同），而是在超时重发时才会设置为当时拥塞窗口的一半大小



重复确认应答而触发的高速重发与超时重发机制处理不同，慢启动阀值大小被设置为当时拥塞窗口大小的一半，但拥塞窗口大小设置为该慢启动阀值+3个数据段的大小



## 提高网络利用率的规范

### Nagle算法

已发送数据都已经收到确认应答时 || 可以发送最大段长度（MSS）的数据 时    才能发送数据



### 延迟确认应答

接收数据的主机立刻回复确认应答的话，会返回一个较小的窗口，因为刚接收数据，缓冲区已满

收到数据后延迟一段时间

- 在没有收到2*最大段长度的数据为止不做确认应答

- 其他情况下，最大延迟0.5s发送确认应答（多于0.5s会导致发送端重发） （很多操作系统设置为0.2s）



TCP采用滑动窗口的控制机制，通常每两个数据段返回一次确认应答



### 捎带应答

根据应用层协议，发送消息到达对端 对端处理后会返回一个回执 这些应用协议使用同一个连接进行数据的交互

TCP确认应答和回执数据可以通过一个包发送，这种方式即捎带应答（PiggyBack Acknowledgement，卖猪时让猪背几篮菜顺带卖）

没有延迟确认就无法实现捎带应答





## 首部

TCP首部总共20B

原端口号2B 目标端口号2B (Source Port、Destination Port)

序列号4B(Sequence Number)

确认应答号4B(Acknowledgement Number)

数据偏移4b（单位4B）(Data Offset)

保留4b(Reserved)

控制位8b(Control Flag)

- CWR(congestion Window Reduced)

- ECE(ECN-Echo)                                     

  CWR,ECE都用于IP首部ECN，ECE为1时同志对方已将拥塞窗口缩小，收到数据包IP首部ECN为1时会TCP中ECE设为1

- URG(Urgent Flag)

- ACK

- PSH(Push Flag) 为1时收到数据立刻传给上层应用协议，为0时则先进行缓存

- RST(Reset Flag) 为1时表示TCP异常强制断连

- SYN 为1时表示希望建立连接，并需在序列号字段进行序列号初始值的设定

- FIN

窗口大小2B（单位B）(Window Size)

校验和(Checksum)

紧急指针(Urgent Pointer)



选项(Options)

- 2 MSS
- 3 窗口扩大
- 8 时间戳 32b序列号用完 区分新老序列号、
- 4、5 SACK(Selective Ackowledgement) 数据时不时丢失，允许以最大x次断断续续数据状态的确认应答，避免无用重发

### 序列号

一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。假设主机A和主机B进行TCP通信，A发送给B的第一个TCP报文段中，序号值被系统初始化为某个随机值ISN（Initial Sequence Number，初始序号值）。那么在该传输方向上（从A到B），后续的TCP报文段中序号值将被系统设置成ISN加上该报文段所携带数据的第一个字节在整个字节流中的偏移。例如，某个TCP报文段传送的数据是字节流中的第1025~2048字节，那么该报文段的序号值就是ISN+1025.另外一个传输方向（从B到A）的TCP报文段的序号值也具有相同的含义。



建立连接和断开连接时发送的SYN、FIN虽然不携带数据，但是也会作为一个字节增加对应的序列号，为啥因为需要应答ack



### 校验和

伪首部 

伪首部的出现：发送方或接收方根据IP报文首部获得8字节的源地址+目的地址、2字节的0字段+UDP协议字段、2字节的数据长度，得到12字节伪首部，临时添加在首部前面。

伪首部的消失：发送方将计算完毕的校验和填入首部的校验和字段后，去除伪首部发送UDP报文。

伪首部的作用：仅为了计算校验和使用。

发送方将UDP伪首部、首部、数据每16位一组进行二进制反码求和，再将求和结果求反码，填入校验和字段。

接收方收到UDP报文后，生成伪首部，将伪首部、首部、数据每16位一组进行二进制反码求和，若求和结果全为1则无差错传输，否则丢弃。



校验和字段的值：校验和字段以外剩下部分的1的补码和

因此校验时 需要包括校验和字段在内的所有数据之和结果为16位全部为1 才是正确的



FCS 帧校验序列（帧尾）

FCS：Frame Check Sequence（帧校验序列），俗称帧尾，即计算机网络数据链路层的协议数据单元（帧）的尾部字段，是一段4个字节的<u>循环冗余校验码</u>。

源节点发送数据帧时，由帧的帧头和数据部分计算得出FCS，目的节点接收到后，用同样的方式再计算一遍FCS，如果与接收到的FCS不同，则认为帧在传输过程中发生了错误，从而选择丢弃这个帧。
FCS提供了一种错误检测机制，用来验证帧在传输过程中的完整性。



为什么数据链路层有FCS还需要Checksum呢

FCS防止噪声干扰导致的错误

Checksum则进行路由器内存故障或程序漏洞导致的数据破坏的检查



## 窗口大小与吞吐量

TCP通信最大吞吐量由窗口大小和往返时间决定。
$$
假定最大吞吐量为T_{max}, 窗口大小为W, 往返时间是RTT,那么最大吞吐量:\\
T_{max} = \frac{W(bit)}{RTT(s)}\\
$$
表示1个TCP连接所能传输的最大吞吐量，建立两个以上连接同时传输时，表示每个连接的最大吞吐量

所以TCP中勇夺个连接传输数据会有更高的网络吞吐量，Web一般同时建立4个左右连接



